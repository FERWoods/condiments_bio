---
title: "DifTopo"
author: "Hector Roux de Bézieux"
date: '`r format(Sys.time(), "%d %B , %Y")`'
output: 
  rmarkdown::html_document:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Using DifTopo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r packages, include=F}
library(knitr)
opts_chunk$set(
  fig.pos = "!h", out.extra = "", warning = F, message = F, 
  fig.align = "center", echo = F
)
```

# Initial pre-processing

We will use a synthetic dataset to illustrate the functionalities of the _DifTopo_ package. We start directly with a dataset where the following steps are assumed to have been run:

+ Obtaining count matrices for each setting (i.e. each condition).
+ Integration and normalization between the conditions.
+ Reduced Dimension Estimations
+ (Clustering)

```{r}
library(DifTopo)
library(slingshot)
library(RColorBrewer)
library(viridis)
set.seed(2071)
data('slingshotExample')
rd <- slingshotExample$rd
cl <- slingshotExample$cl
condition <- factor(rep(c('A','B'), length.out = nrow(rd)))
condition[110:139] <- 'A'
ls()
```

As such, we start with a matrix `rd` of the cells in the reduced dimension space. In addition, we have a vector conditions `conditions` and a vector a cluster labels `cl`. 

For a more complete example, please see our [Bioconductor Workshop](https://kstreet13.github.io/bioc2020trajectories/articles/workshopTrajectories.html) on ‘Trajectory inference across conditions: differential expression and differential progression’.

# Differential Topology
## Exploratory analysis

We can first plot the cells on the reduced dimensions

```{r}
plot(rd, asp = 1, pch = 16, col = brewer.pal(3,'Set1')[condition], las=1)
legend('topleft','(x,y)',legend = c('A','B'), title = 'Condition', pch=16, col = brewer.pal(3,'Set1')[1:2])
```
We can then compute the __proximity score__ of each cell using the *proximity_score* function.

```{r}
scores <- proximity_score(Object = rd, conditions = condition)
```

There are two types of scores. The raw score is computed on each cell and looks at the condition distribution of its neighbors compared the the overall distribution. The size of the neighborhood can be set using the `k` argument, which specify the number of neighbors to consider. Higher values means more local imbalance. 

```{r}
grad <- viridis::plasma(10, begin = 0, end = 1)
names(grad) <- levels(cut(scores$scores, breaks = 10))
plot(rd, col = grad[cut(scores$scores, breaks = 10)],
     asp = 1, pch = 16, xlab = "UMAP-1", ylab = "UMAP-2", cex = .8)
legend("topleft", legend = names(grad), col = grad, pch = 16, bty = "n", cex = 2 / 3)
```
We can then use local smoothers to smooth the scores of individual cells. The smoothness is dictated by the `smooth` argument.

```{r}
grad <- viridis::plasma(10, begin = 0, end = 1)
names(grad) <- levels(cut(scores$scaled_scores, breaks = 10))
plot(rd, col = grad[cut(scores$scaled_scores, breaks = 10)],
     asp = 1, pch = 16, xlab = "UMAP-1", ylab = "UMAP-2", cex = .8)
legend("topleft", legend = names(grad), col = grad, pch = 16, bty = "n", cex = 2 / 3)
```

As could be guessed from the original plot, the bottom lineage shows a lot of imbalance while the top one does not. 

The proximity score can be used to check whether the integration has been successful (at least some regions should be balanced), or to identify the regions of imbalance for further analyses.

## Trajectory Inference

The first step of our workflow is to decide whether or not to infer the trajectories separately or not. On average, it is better to infer a common trajectory, since a) this allow for a wider range of downstream analyses, and b) more cells are used to estimate the trajectory. However, the condition effect might be strong enough to massively disrupt the differentiation process, which would require fitting separate trajectories. 

The __diffTopoTest__ assess the quality of the common trajectory inference done by slingshot and test whether we should fit a common or separate trajectory. This test relies on permutations of the conditions followed by trajectory inference so it can take a few seconds. It uses a modified version of the  Kolmogorov-Smirnov Two-Sample Test , use `?ks_test` for more details.

```{r}
sds <- slingshot(rd, cl)
## Takes ~1mn30s to run
diffTopoTest(sds = sds, conditions = condition)
```

The test fails to reject the null that we can fit a common trajectory so we can continue with the `sds` object.

# Differential Progression

Even though 

# Session Info

```{r}
sessionInfo()
```
